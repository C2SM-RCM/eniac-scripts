--- eniac_a/src/atm_dyn_iconam/mo_velocity_advection.f90	2019-04-16 14:07:57.000000000 +0200
+++ eniac_b/src/atm_dyn_iconam/mo_velocity_advection.f90	2019-04-16 14:06:53.000000000 +0200
@@ -67,6 +67,21 @@
   LOGICAL, PARAMETER ::  acc_validate = .FALSE.     !  THIS SHOULD BE .FALSE. AFTER VALIDATION PHASE!
 #endif
 
+
+! ================= BEGIN FORTRAN TEST GENERATOR (FTG) =======================
+
+LOGICAL :: ftg_velocity_tendencies_capture_input_enabled = .TRUE.
+LOGICAL :: ftg_velocity_tendencies_capture_output_enabled = .TRUE.
+INTEGER :: ftg_velocity_tendencies_capture_round = 1
+INTEGER :: ftg_velocity_tendencies_round = 0
+CHARACTER(len=1024) :: ftg_velocity_tendencies_data_dir = &
+&  '/scratch/snx3000/pmarti/new_FTG/icon-eniac/experiments/ftg/ftg_velocity_tendencies_test/'
+
+PUBLIC :: ftg_velocity_tendencies_capture_input_enabled, ftg_velocity_tendencies_capture_output_enabled, &
+&  ftg_velocity_tendencies_capture_round, ftg_velocity_tendencies_data_dir
+
+! ================= END FORTRAN TEST GENERATOR (FTG) =========================
+
   CONTAINS
 
 
@@ -158,6 +173,21 @@
 !DIR$ ATTRIBUTES ALIGN :64 :: z_v_grad_w,z_w_v,zeta,z_ekinh
 !DIR$ ATTRIBUTES ALIGN :64 :: levmask,cfl_clipping
 #endif
+
+! ================= BEGIN FORTRAN TEST GENERATOR (FTG) =======================
+
+LOGICAL :: ftg_velocity_tendencies_capture_active_local
+
+ftg_velocity_tendencies_capture_active_local = .FALSE.
+ftg_velocity_tendencies_round = ftg_velocity_tendencies_round + 1
+IF (ftg_velocity_tendencies_capture_input_enabled .AND. ftg_velocity_tendencies_capture_active()) THEN
+  CALL ftg_velocity_tendencies_capture_data('input', p_prog, p_patch, p_int, p_metrics, p_diag, z_w_concorr_me, z_kin_hor_e, &
+  &  z_vt_ie, ntnd, istep, lvn_only, dtime)
+  ftg_velocity_tendencies_capture_active_local = .TRUE.
+END IF
+
+! ================= END FORTRAN TEST GENERATOR (FTG) =========================
+
     !--------------------------------------------------------------------------
 
     IF (timers_level > 5) CALL timer_start(timer_solve_nh_veltend)
@@ -773,8 +803,424 @@
 
     IF (timers_level > 5) CALL timer_stop(timer_solve_nh_veltend)
 
+
+! ================= BEGIN FORTRAN TEST GENERATOR (FTG) =======================
+
+IF (ftg_velocity_tendencies_capture_output_enabled .AND. ftg_velocity_tendencies_capture_active_local) THEN
+  CALL ftg_velocity_tendencies_capture_data('output', p_prog, p_patch, p_int, p_metrics, p_diag, z_w_concorr_me, z_kin_hor_e, &
+  &  z_vt_ie, ntnd, istep, lvn_only, dtime)
+END IF
+
+! ================= END FORTRAN TEST GENERATOR (FTG) =========================
+
   END SUBROUTINE velocity_tendencies
 
+! ================= BEGIN FORTRAN TEST GENERATOR (FTG) =======================
+
+LOGICAL FUNCTION ftg_velocity_tendencies_capture_active()
+
+CHARACTER(len=1024) :: executable
+INTEGER :: executable_len
+
+CALL get_command_argument(0, executable)
+executable_len = LEN(TRIM(executable))
+
+ftg_velocity_tendencies_capture_active =                                              &
+executable_len >= 8 .AND. executable(executable_len-7:executable_len) == 'bin/icon' .AND. &
+ftg_velocity_tendencies_round == ftg_velocity_tendencies_capture_round
+
+END FUNCTION ftg_velocity_tendencies_capture_active
+
+SUBROUTINE ftg_velocity_tendencies_init_serializer(stage)
+  
+  USE mo_mpi, ONLY: get_my_mpi_all_id
+  USE m_ser_ftg, ONLY: ftg_set_serializer, ftg_add_serializer_metainfo, ftg_set_savepoint, ftg_add_savepoint_metainfo, &
+  &  ignore_bullshit_max_dim_size, ignore_bullshit_allow_negative_indices
+  
+  CHARACTER(*), INTENT(IN) :: stage
+  
+  INTEGER :: mpi_rank
+  CHARACTER(len=256) :: basename, dir, mkdir_err
+  
+  mpi_rank = get_my_mpi_all_id()
+  
+  WRITE (basename,'(A,A,A,I0.2)') 'ftg_velocity_tendencies_', TRIM(stage), '_', mpi_rank
+  WRITE (dir,'(A,A)') TRIM(ftg_velocity_tendencies_data_dir), TRIM(stage)
+  WRITE (0,'(A,A,A,I0.2,A,I0,A)') 'FTG WRITE STARTED velocity_tendencies: ', TRIM(stage), ' (Rank #', mpi_rank, ', round: ', &
+  &  ftg_velocity_tendencies_round, ')'
+  
+  mkdir_err = ''
+  CALL EXECUTE_COMMAND_LINE('mkdir -p '//TRIM(dir), cmdmsg=mkdir_err)
+  IF (TRIM(mkdir_err) /= '') THEN
+    WRITE (0,'(A,A,A)') 'FTG INIT *** ERROR: ', TRIM(mkdir_err), ' ***'
+  END IF
+  
+  ignore_bullshit_max_dim_size = 100000
+  ignore_bullshit_allow_negative_indices = .TRUE.
+  
+  CALL ftg_set_serializer(TRIM(dir), TRIM(basename), 'w')
+  CALL ftg_add_serializer_metainfo('subroutine', 'velocity_tendencies')
+  CALL ftg_add_serializer_metainfo('stage', stage)
+  CALL ftg_add_serializer_metainfo('mpi_rank', mpi_rank)
+  
+  CALL ftg_set_savepoint(TRIM(stage))
+  
+END SUBROUTINE ftg_velocity_tendencies_init_serializer
+
+SUBROUTINE ftg_velocity_tendencies_close_serializer(stage)
+  
+  USE mo_mpi, ONLY: get_my_mpi_all_id, work_mpi_barrier
+  USE mo_exception, ONLY: finish
+  USE m_ser_ftg, ONLY: ftg_destroy_savepoint, ftg_destroy_serializer
+  
+  CHARACTER(*), INTENT(IN) :: stage
+  
+  WRITE (0,'(A,A,A,I0.2,A)') 'FTG WRITE FINISHED velocity_tendencies: ', TRIM(stage), ' (Rank #', get_my_mpi_all_id(), ')'
+  
+  CALL ftg_destroy_savepoint()
+  CALL ftg_destroy_serializer()
+  
+  IF (stage == 'output') THEN
+    CALL work_mpi_barrier()
+    CALL finish('FTG EXIT', 'Output captured: velocity_tendencies', 0)
+  END IF
+  
+END SUBROUTINE ftg_velocity_tendencies_close_serializer
+
+SUBROUTINE ftg_velocity_tendencies_capture_data(stage, p_prog, p_patch, p_int, p_metrics, p_diag, z_w_concorr_me, z_kin_hor_e, &
+&  z_vt_ie, ntnd, istep, lvn_only, dtime)
+  
+  USE mtime, ONLY: calendarType
+  USE m_ser_ftg, ONLY: ftg_write, ftg_register_only
+  
+  USE mo_init_vgrid, ONLY: mo_init_vgrid__nflatlev => nflatlev
+  USE mo_nonhydrostatic_config, ONLY: mo_nonhydrostatic_config__lextra_diffu => lextra_diffu
+  USE mo_parallel_config, ONLY: mo_parallel_config__nproma => nproma
+  USE mo_real_timer, ONLY: mo_real_timer__active_timers => active_timers, mo_real_timer__active_timers_top => active_timers_top, &
+  &  mo_real_timer__delta_i => delta_i, mo_real_timer__rt => rt, mo_real_timer__srt => srt, mo_real_timer__timer_top => timer_top
+  USE mo_run_config, ONLY: mo_run_config__ltimer => ltimer, mo_run_config__lvert_nest => lvert_nest, mo_run_config__timers_level &
+  &  => timers_level
+  USE mo_timer, ONLY: mo_timer__timer_intp => timer_intp, mo_timer__timer_solve_nh_veltend => timer_solve_nh_veltend
+  USE mo_vertical_grid, ONLY: mo_vertical_grid__nrdmax => nrdmax
+  USE mo_intp_data_strc, ONLY: t_int_state
+  USE mo_model_domain, ONLY: t_patch
+  USE mo_nonhydro_types, ONLY: t_nh_diag, t_nh_metrics, t_nh_prog
+  
+  CHARACTER(*), INTENT(IN) :: stage
+  TYPE(t_nh_prog), INTENT(in) :: p_prog
+  TYPE(t_patch), INTENT(in) :: p_patch
+  TYPE(t_int_state), INTENT(in) :: p_int
+  TYPE(t_nh_metrics), INTENT(in) :: p_metrics
+  TYPE(t_nh_diag), INTENT(in) :: p_diag
+  REAL(vp), DIMENSION(:,:,:), INTENT(in) :: z_w_concorr_me
+  REAL(vp), DIMENSION(:,:,:), INTENT(in) :: z_kin_hor_e
+  REAL(vp), DIMENSION(:,:,:), INTENT(in) :: z_vt_ie
+  INTEGER, INTENT(in) :: ntnd
+  INTEGER, INTENT(in) :: istep
+  LOGICAL, INTENT(in) :: lvn_only
+  REAL(wp), INTENT(in) :: dtime
+  
+  INTEGER :: ftg_d1, ftg_d2, ftg_d3, ftg_d4, ftg_d5, ftg_d6
+  CHARACTER(len=256) :: ftg_name
+  
+  CALL ftg_velocity_tendencies_init_serializer(stage)
+  
+  
+  IF (stage == 'input') THEN
+    ! MTIME CALENDAR TYPE --> Remove this line if mtime is not used
+    CALL ftg_write("ftg_mtime_calendar", calendarType())
+    
+    ! REQUIRED IN ARGUMENTS
+    CALL ftg_register_only("p_patch", "TYPE(t_patch)")
+    CALL ftg_write("p_patch%id", p_patch%id)
+    CALL ftg_write("p_patch%n_childdom", p_patch%n_childdom)
+    CALL ftg_write("p_patch%nblks_c", p_patch%nblks_c)
+    CALL ftg_write("p_patch%nblks_e", p_patch%nblks_e)
+    CALL ftg_write("p_patch%nblks_v", p_patch%nblks_v)
+    CALL ftg_write("p_patch%nlev", p_patch%nlev)
+    CALL ftg_write("p_patch%nlevp1", p_patch%nlevp1)
+    CALL ftg_write("p_patch%nshift", p_patch%nshift)
+    CALL ftg_register_only("p_patch%cells", "TYPE(t_grid_cells)")
+    IF (ASSOCIATED(p_patch%cells%area)) THEN
+      CALL ftg_write("p_patch%cells%area", p_patch%cells%area, LBOUND(p_patch%cells%area), UBOUND(p_patch%cells%area))
+    END IF
+    IF (ALLOCATED(p_patch%cells%edge_blk)) THEN
+      CALL ftg_write("p_patch%cells%edge_blk", p_patch%cells%edge_blk, LBOUND(p_patch%cells%edge_blk), UBOUND(p_patch%cells% &
+      &  edge_blk))
+    END IF
+    IF (ALLOCATED(p_patch%cells%edge_idx)) THEN
+      CALL ftg_write("p_patch%cells%edge_idx", p_patch%cells%edge_idx, LBOUND(p_patch%cells%edge_idx), UBOUND(p_patch%cells% &
+      &  edge_idx))
+    END IF
+    IF (ALLOCATED(p_patch%cells%end_block)) THEN
+      CALL ftg_write("p_patch%cells%end_block", p_patch%cells%end_block, LBOUND(p_patch%cells%end_block), UBOUND(p_patch%cells% &
+      &  end_block))
+    END IF
+    IF (ALLOCATED(p_patch%cells%end_index)) THEN
+      CALL ftg_write("p_patch%cells%end_index", p_patch%cells%end_index, LBOUND(p_patch%cells%end_index), UBOUND(p_patch%cells% &
+      &  end_index))
+    END IF
+    IF (ALLOCATED(p_patch%cells%neighbor_blk)) THEN
+      CALL ftg_write("p_patch%cells%neighbor_blk", p_patch%cells%neighbor_blk, LBOUND(p_patch%cells%neighbor_blk), UBOUND(p_patch% &
+      &  cells%neighbor_blk))
+    END IF
+    IF (ALLOCATED(p_patch%cells%neighbor_idx)) THEN
+      CALL ftg_write("p_patch%cells%neighbor_idx", p_patch%cells%neighbor_idx, LBOUND(p_patch%cells%neighbor_idx), UBOUND(p_patch% &
+      &  cells%neighbor_idx))
+    END IF
+    IF (ALLOCATED(p_patch%cells%start_block)) THEN
+      CALL ftg_write("p_patch%cells%start_block", p_patch%cells%start_block, LBOUND(p_patch%cells%start_block), UBOUND(p_patch% &
+      &  cells%start_block))
+    END IF
+    IF (ALLOCATED(p_patch%cells%start_index)) THEN
+      CALL ftg_write("p_patch%cells%start_index", p_patch%cells%start_index, LBOUND(p_patch%cells%start_index), UBOUND(p_patch% &
+      &  cells%start_index))
+    END IF
+    CALL ftg_register_only("p_patch%edges", "TYPE(t_grid_edges)")
+    IF (ALLOCATED(p_patch%edges%area_edge)) THEN
+      CALL ftg_write("p_patch%edges%area_edge", p_patch%edges%area_edge, LBOUND(p_patch%edges%area_edge), UBOUND(p_patch%edges% &
+      &  area_edge))
+    END IF
+    IF (ALLOCATED(p_patch%edges%cell_blk)) THEN
+      CALL ftg_write("p_patch%edges%cell_blk", p_patch%edges%cell_blk, LBOUND(p_patch%edges%cell_blk), UBOUND(p_patch%edges% &
+      &  cell_blk))
+    END IF
+    IF (ALLOCATED(p_patch%edges%cell_idx)) THEN
+      CALL ftg_write("p_patch%edges%cell_idx", p_patch%edges%cell_idx, LBOUND(p_patch%edges%cell_idx), UBOUND(p_patch%edges% &
+      &  cell_idx))
+    END IF
+    IF (ALLOCATED(p_patch%edges%end_block)) THEN
+      CALL ftg_write("p_patch%edges%end_block", p_patch%edges%end_block, LBOUND(p_patch%edges%end_block), UBOUND(p_patch%edges% &
+      &  end_block))
+    END IF
+    IF (ALLOCATED(p_patch%edges%end_index)) THEN
+      CALL ftg_write("p_patch%edges%end_index", p_patch%edges%end_index, LBOUND(p_patch%edges%end_index), UBOUND(p_patch%edges% &
+      &  end_index))
+    END IF
+    IF (ALLOCATED(p_patch%edges%f_e)) THEN
+      CALL ftg_write("p_patch%edges%f_e", p_patch%edges%f_e, LBOUND(p_patch%edges%f_e), UBOUND(p_patch%edges%f_e))
+    END IF
+    IF (ALLOCATED(p_patch%edges%inv_dual_edge_length)) THEN
+      CALL ftg_write("p_patch%edges%inv_dual_edge_length", p_patch%edges%inv_dual_edge_length, LBOUND(p_patch%edges% &
+      &  inv_dual_edge_length), UBOUND(p_patch%edges%inv_dual_edge_length))
+    END IF
+    IF (ALLOCATED(p_patch%edges%inv_primal_edge_length)) THEN
+      CALL ftg_write("p_patch%edges%inv_primal_edge_length", p_patch%edges%inv_primal_edge_length, LBOUND(p_patch%edges% &
+      &  inv_primal_edge_length), UBOUND(p_patch%edges%inv_primal_edge_length))
+    END IF
+    IF (ALLOCATED(p_patch%edges%quad_blk)) THEN
+      CALL ftg_write("p_patch%edges%quad_blk", p_patch%edges%quad_blk, LBOUND(p_patch%edges%quad_blk), UBOUND(p_patch%edges% &
+      &  quad_blk))
+    END IF
+    IF (ALLOCATED(p_patch%edges%quad_idx)) THEN
+      CALL ftg_write("p_patch%edges%quad_idx", p_patch%edges%quad_idx, LBOUND(p_patch%edges%quad_idx), UBOUND(p_patch%edges% &
+      &  quad_idx))
+    END IF
+    IF (ALLOCATED(p_patch%edges%start_block)) THEN
+      CALL ftg_write("p_patch%edges%start_block", p_patch%edges%start_block, LBOUND(p_patch%edges%start_block), UBOUND(p_patch% &
+      &  edges%start_block))
+    END IF
+    IF (ALLOCATED(p_patch%edges%start_index)) THEN
+      CALL ftg_write("p_patch%edges%start_index", p_patch%edges%start_index, LBOUND(p_patch%edges%start_index), UBOUND(p_patch% &
+      &  edges%start_index))
+    END IF
+    IF (ALLOCATED(p_patch%edges%tangent_orientation)) THEN
+      CALL ftg_write("p_patch%edges%tangent_orientation", p_patch%edges%tangent_orientation, LBOUND(p_patch%edges% &
+      &  tangent_orientation), UBOUND(p_patch%edges%tangent_orientation))
+    END IF
+    IF (ALLOCATED(p_patch%edges%vertex_blk)) THEN
+      CALL ftg_write("p_patch%edges%vertex_blk", p_patch%edges%vertex_blk, LBOUND(p_patch%edges%vertex_blk), UBOUND(p_patch%edges% &
+      &  vertex_blk))
+    END IF
+    IF (ALLOCATED(p_patch%edges%vertex_idx)) THEN
+      CALL ftg_write("p_patch%edges%vertex_idx", p_patch%edges%vertex_idx, LBOUND(p_patch%edges%vertex_idx), UBOUND(p_patch%edges% &
+      &  vertex_idx))
+    END IF
+    CALL ftg_register_only("p_patch%verts", "TYPE(t_grid_vertices)")
+    IF (ALLOCATED(p_patch%verts%cell_blk)) THEN
+      CALL ftg_write("p_patch%verts%cell_blk", p_patch%verts%cell_blk, LBOUND(p_patch%verts%cell_blk), UBOUND(p_patch%verts% &
+      &  cell_blk))
+    END IF
+    IF (ALLOCATED(p_patch%verts%cell_idx)) THEN
+      CALL ftg_write("p_patch%verts%cell_idx", p_patch%verts%cell_idx, LBOUND(p_patch%verts%cell_idx), UBOUND(p_patch%verts% &
+      &  cell_idx))
+    END IF
+    IF (ALLOCATED(p_patch%verts%edge_blk)) THEN
+      CALL ftg_write("p_patch%verts%edge_blk", p_patch%verts%edge_blk, LBOUND(p_patch%verts%edge_blk), UBOUND(p_patch%verts% &
+      &  edge_blk))
+    END IF
+    IF (ALLOCATED(p_patch%verts%edge_idx)) THEN
+      CALL ftg_write("p_patch%verts%edge_idx", p_patch%verts%edge_idx, LBOUND(p_patch%verts%edge_idx), UBOUND(p_patch%verts% &
+      &  edge_idx))
+    END IF
+    IF (ALLOCATED(p_patch%verts%end_blk)) THEN
+      CALL ftg_write("p_patch%verts%end_blk", p_patch%verts%end_blk, LBOUND(p_patch%verts%end_blk), UBOUND(p_patch%verts%end_blk))
+    END IF
+    IF (ALLOCATED(p_patch%verts%end_block)) THEN
+      CALL ftg_write("p_patch%verts%end_block", p_patch%verts%end_block, LBOUND(p_patch%verts%end_block), UBOUND(p_patch%verts% &
+      &  end_block))
+    END IF
+    IF (ALLOCATED(p_patch%verts%end_index)) THEN
+      CALL ftg_write("p_patch%verts%end_index", p_patch%verts%end_index, LBOUND(p_patch%verts%end_index), UBOUND(p_patch%verts% &
+      &  end_index))
+    END IF
+    IF (ALLOCATED(p_patch%verts%start_blk)) THEN
+      CALL ftg_write("p_patch%verts%start_blk", p_patch%verts%start_blk, LBOUND(p_patch%verts%start_blk), UBOUND(p_patch%verts% &
+      &  start_blk))
+    END IF
+    IF (ALLOCATED(p_patch%verts%start_block)) THEN
+      CALL ftg_write("p_patch%verts%start_block", p_patch%verts%start_block, LBOUND(p_patch%verts%start_block), UBOUND(p_patch% &
+      &  verts%start_block))
+    END IF
+    IF (ALLOCATED(p_patch%verts%start_index)) THEN
+      CALL ftg_write("p_patch%verts%start_index", p_patch%verts%start_index, LBOUND(p_patch%verts%start_index), UBOUND(p_patch% &
+      &  verts%start_index))
+    END IF
+    CALL ftg_register_only("p_patch%cells%decomp_info", "TYPE(t_grid_domain_decomp_info)")
+    IF (ALLOCATED(p_patch%cells%decomp_info%owner_mask)) THEN
+      CALL ftg_write("p_patch%cells%decomp_info%owner_mask", p_patch%cells%decomp_info%owner_mask, LBOUND(p_patch%cells% &
+      &  decomp_info%owner_mask), UBOUND(p_patch%cells%decomp_info%owner_mask))
+    END IF
+    CALL ftg_register_only("p_int", "TYPE(t_int_state)")
+    IF (ALLOCATED(p_int%c_lin_e)) THEN
+      CALL ftg_write("p_int%c_lin_e", p_int%c_lin_e, LBOUND(p_int%c_lin_e), UBOUND(p_int%c_lin_e))
+    END IF
+    IF (ALLOCATED(p_int%cells_aw_verts)) THEN
+      CALL ftg_write("p_int%cells_aw_verts", p_int%cells_aw_verts, LBOUND(p_int%cells_aw_verts), UBOUND(p_int%cells_aw_verts))
+    END IF
+    IF (ALLOCATED(p_int%e_bln_c_s)) THEN
+      CALL ftg_write("p_int%e_bln_c_s", p_int%e_bln_c_s, LBOUND(p_int%e_bln_c_s), UBOUND(p_int%e_bln_c_s))
+    END IF
+    IF (ALLOCATED(p_int%geofac_grdiv)) THEN
+      CALL ftg_write("p_int%geofac_grdiv", p_int%geofac_grdiv, LBOUND(p_int%geofac_grdiv), UBOUND(p_int%geofac_grdiv))
+    END IF
+    IF (ALLOCATED(p_int%geofac_n2s)) THEN
+      CALL ftg_write("p_int%geofac_n2s", p_int%geofac_n2s, LBOUND(p_int%geofac_n2s), UBOUND(p_int%geofac_n2s))
+    END IF
+    IF (ALLOCATED(p_int%geofac_rot)) THEN
+      CALL ftg_write("p_int%geofac_rot", p_int%geofac_rot, LBOUND(p_int%geofac_rot), UBOUND(p_int%geofac_rot))
+    END IF
+    IF (ALLOCATED(p_int%rbf_vec_coeff_e)) THEN
+      CALL ftg_write("p_int%rbf_vec_coeff_e", p_int%rbf_vec_coeff_e, LBOUND(p_int%rbf_vec_coeff_e), UBOUND(p_int%rbf_vec_coeff_e))
+    END IF
+    CALL ftg_write("ntnd", ntnd)
+    CALL ftg_write("istep", istep)
+    CALL ftg_write("lvn_only", lvn_only)
+    CALL ftg_write("dtime", dtime)
+    
+    ! OPTIONAL IN ARGUMENTS
+  END IF
+  
+  ! REQUIRED OUT + INOUT ARGUMENTS
+  CALL ftg_register_only("p_prog", "TYPE(t_nh_prog)")
+  IF (ASSOCIATED(p_prog%vn)) THEN
+    CALL ftg_write("p_prog%vn", p_prog%vn, LBOUND(p_prog%vn), UBOUND(p_prog%vn))
+  END IF
+  IF (ASSOCIATED(p_prog%w)) THEN
+    CALL ftg_write("p_prog%w", p_prog%w, LBOUND(p_prog%w), UBOUND(p_prog%w))
+  END IF
+  CALL ftg_register_only("p_metrics", "TYPE(t_nh_metrics)")
+  IF (ASSOCIATED(p_metrics%coeff1_dwdz)) THEN
+    CALL ftg_write("p_metrics%coeff1_dwdz", p_metrics%coeff1_dwdz, LBOUND(p_metrics%coeff1_dwdz), UBOUND(p_metrics%coeff1_dwdz))
+  END IF
+  IF (ASSOCIATED(p_metrics%coeff2_dwdz)) THEN
+    CALL ftg_write("p_metrics%coeff2_dwdz", p_metrics%coeff2_dwdz, LBOUND(p_metrics%coeff2_dwdz), UBOUND(p_metrics%coeff2_dwdz))
+  END IF
+  IF (ASSOCIATED(p_metrics%coeff_gradekin)) THEN
+    CALL ftg_write("p_metrics%coeff_gradekin", p_metrics%coeff_gradekin, LBOUND(p_metrics%coeff_gradekin), UBOUND(p_metrics% &
+    &  coeff_gradekin))
+  END IF
+  IF (ASSOCIATED(p_metrics%ddqz_z_full_e)) THEN
+    CALL ftg_write("p_metrics%ddqz_z_full_e", p_metrics%ddqz_z_full_e, LBOUND(p_metrics%ddqz_z_full_e), UBOUND(p_metrics% &
+    &  ddqz_z_full_e))
+  END IF
+  IF (ASSOCIATED(p_metrics%ddqz_z_half)) THEN
+    CALL ftg_write("p_metrics%ddqz_z_half", p_metrics%ddqz_z_half, LBOUND(p_metrics%ddqz_z_half), UBOUND(p_metrics%ddqz_z_half))
+  END IF
+  IF (ASSOCIATED(p_metrics%ddxn_z_full)) THEN
+    CALL ftg_write("p_metrics%ddxn_z_full", p_metrics%ddxn_z_full, LBOUND(p_metrics%ddxn_z_full), UBOUND(p_metrics%ddxn_z_full))
+  END IF
+  IF (ASSOCIATED(p_metrics%ddxt_z_full)) THEN
+    CALL ftg_write("p_metrics%ddxt_z_full", p_metrics%ddxt_z_full, LBOUND(p_metrics%ddxt_z_full), UBOUND(p_metrics%ddxt_z_full))
+  END IF
+  IF (ASSOCIATED(p_metrics%wgtfac_c)) THEN
+    CALL ftg_write("p_metrics%wgtfac_c", p_metrics%wgtfac_c, LBOUND(p_metrics%wgtfac_c), UBOUND(p_metrics%wgtfac_c))
+  END IF
+  IF (ASSOCIATED(p_metrics%wgtfac_e)) THEN
+    CALL ftg_write("p_metrics%wgtfac_e", p_metrics%wgtfac_e, LBOUND(p_metrics%wgtfac_e), UBOUND(p_metrics%wgtfac_e))
+  END IF
+  IF (ASSOCIATED(p_metrics%wgtfacq_e)) THEN
+    CALL ftg_write("p_metrics%wgtfacq_e", p_metrics%wgtfacq_e, LBOUND(p_metrics%wgtfacq_e), UBOUND(p_metrics%wgtfacq_e))
+  END IF
+  CALL ftg_register_only("p_diag", "TYPE(t_nh_diag)")
+  IF (ASSOCIATED(p_diag%ddt_vn_adv)) THEN
+    CALL ftg_write("p_diag%ddt_vn_adv", p_diag%ddt_vn_adv, LBOUND(p_diag%ddt_vn_adv), UBOUND(p_diag%ddt_vn_adv))
+  END IF
+  IF (ASSOCIATED(p_diag%ddt_w_adv)) THEN
+    CALL ftg_write("p_diag%ddt_w_adv", p_diag%ddt_w_adv, LBOUND(p_diag%ddt_w_adv), UBOUND(p_diag%ddt_w_adv))
+  END IF
+  IF (ASSOCIATED(p_diag%dvn_ie_ubc)) THEN
+    CALL ftg_write("p_diag%dvn_ie_ubc", p_diag%dvn_ie_ubc, LBOUND(p_diag%dvn_ie_ubc), UBOUND(p_diag%dvn_ie_ubc))
+  END IF
+  CALL ftg_write("p_diag%max_vcfl_dyn", p_diag%max_vcfl_dyn)
+  IF (ASSOCIATED(p_diag%vn_ie)) THEN
+    CALL ftg_write("p_diag%vn_ie", p_diag%vn_ie, LBOUND(p_diag%vn_ie), UBOUND(p_diag%vn_ie))
+  END IF
+  IF (ASSOCIATED(p_diag%vt)) THEN
+    CALL ftg_write("p_diag%vt", p_diag%vt, LBOUND(p_diag%vt), UBOUND(p_diag%vt))
+  END IF
+  IF (ASSOCIATED(p_diag%w_concorr_c)) THEN
+    CALL ftg_write("p_diag%w_concorr_c", p_diag%w_concorr_c, LBOUND(p_diag%w_concorr_c), UBOUND(p_diag%w_concorr_c))
+  END IF
+  CALL ftg_write("z_w_concorr_me", z_w_concorr_me, LBOUND(z_w_concorr_me), UBOUND(z_w_concorr_me))
+  CALL ftg_write("z_kin_hor_e", z_kin_hor_e, LBOUND(z_kin_hor_e), UBOUND(z_kin_hor_e))
+  CALL ftg_write("z_vt_ie", z_vt_ie, LBOUND(z_vt_ie), UBOUND(z_vt_ie))
+  
+  ! OPTIONAL OUT + INOUT ARGUMENTS
+  
+  
+  ! GLOBALS
+  CALL ftg_write("mo_real_timer__active_timers", mo_real_timer__active_timers, LBOUND(mo_real_timer__active_timers), UBOUND( &
+  &  mo_real_timer__active_timers))
+  CALL ftg_write("mo_real_timer__active_timers_top", mo_real_timer__active_timers_top)
+  CALL ftg_write("mo_real_timer__delta_i", mo_real_timer__delta_i)
+  CALL ftg_write("mo_nonhydrostatic_config__lextra_diffu", mo_nonhydrostatic_config__lextra_diffu)
+  CALL ftg_write("mo_run_config__ltimer", mo_run_config__ltimer)
+  CALL ftg_write("mo_run_config__lvert_nest", mo_run_config__lvert_nest)
+  CALL ftg_write("mo_init_vgrid__nflatlev", mo_init_vgrid__nflatlev, LBOUND(mo_init_vgrid__nflatlev), UBOUND( &
+  &  mo_init_vgrid__nflatlev))
+  CALL ftg_write("mo_parallel_config__nproma", mo_parallel_config__nproma)
+  CALL ftg_write("mo_vertical_grid__nrdmax", mo_vertical_grid__nrdmax, LBOUND(mo_vertical_grid__nrdmax), UBOUND( &
+  &  mo_vertical_grid__nrdmax))
+  CALL ftg_write("mo_timer__timer_intp", mo_timer__timer_intp)
+  CALL ftg_write("mo_timer__timer_solve_nh_veltend", mo_timer__timer_solve_nh_veltend)
+  CALL ftg_write("mo_real_timer__timer_top", mo_real_timer__timer_top)
+  CALL ftg_write("mo_run_config__timers_level", mo_run_config__timers_level)
+  CALL ftg_register_only("mo_real_timer__rt", "TYPE(t_rt)", LBOUND(mo_real_timer__rt), UBOUND(mo_real_timer__rt))
+  CALL ftg_write("mo_real_timer__rt%active_under", mo_real_timer__rt%active_under, LBOUND(mo_real_timer__rt%active_under), UBOUND( &
+  &  mo_real_timer__rt%active_under))
+  CALL ftg_write("mo_real_timer__rt%call_n", mo_real_timer__rt%call_n, LBOUND(mo_real_timer__rt%call_n), UBOUND(mo_real_timer__rt% &
+  &  call_n))
+  CALL ftg_write("mo_real_timer__rt%last", mo_real_timer__rt%last, LBOUND(mo_real_timer__rt%last), UBOUND(mo_real_timer__rt%last))
+  CALL ftg_write("mo_real_timer__rt%mark1", mo_real_timer__rt%mark1, LBOUND(mo_real_timer__rt%mark1), UBOUND(mo_real_timer__rt% &
+  &  mark1))
+  CALL ftg_write("mo_real_timer__rt%max", mo_real_timer__rt%max, LBOUND(mo_real_timer__rt%max), UBOUND(mo_real_timer__rt%max))
+  CALL ftg_write("mo_real_timer__rt%min", mo_real_timer__rt%min, LBOUND(mo_real_timer__rt%min), UBOUND(mo_real_timer__rt%min))
+  CALL ftg_write("mo_real_timer__rt%stat", mo_real_timer__rt%stat, LBOUND(mo_real_timer__rt%stat), UBOUND(mo_real_timer__rt%stat))
+  CALL ftg_write("mo_real_timer__rt%tot", mo_real_timer__rt%tot, LBOUND(mo_real_timer__rt%tot), UBOUND(mo_real_timer__rt%tot))
+  ! *** WARNING: Type not supported by serialbox ***
+  !     mo_real_timer__srt%text
+  !     CHARACTER(len=80), DIMENSION(0)
+  
+  CALL ftg_write("ftg_velocity_tendencies_round", ftg_velocity_tendencies_round)
+  
+  CALL ftg_velocity_tendencies_close_serializer(stage)
+  
+END SUBROUTINE ftg_velocity_tendencies_capture_data
+
+! ================= END FORTRAN TEST GENERATOR (FTG) =========================
+
+
 #ifdef _OPENACC
      SUBROUTINE h2d_velocity_tendencies( ntnd, p_prog, p_diag, z_w_concorr_me, z_kin_hor_e, z_vt_ie )
        INTEGER, INTENT(IN)                       :: ntnd
